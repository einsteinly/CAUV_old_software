/***  This is a generated file, do not edit ***/
\#include "workarounds.h" // _must_ be first
\#include <boost/python.hpp>
\#include <boost/python/str.hpp>

\#include "emit_generated.h"
\#include "../common/messages.h"

namespace bp = boost::python;

void emitRequiredContainers();
#set $requiredVectorTypes = []
#set $requiredMapTypes = []

void emitMessages(){
    #for $g in $groups
    #for $m in $g.messages
    #set $className = $m.name + "Message"

    ## Cheetah fun to generate the boost::python::init object:
    #set $initString = "bp::init< "
    #for $i, $f in enumerate($m.fields)
        ## There is probably a better way to append to a list...
        #if $isSTLVector($f.type)
            #set $requiredVectorTypes = $requiredVectorTypes + [$f.type.valType]
        #else if $isSTLMap($f.type)
            #set $requiredMapTypes = $requiredMapTypes + [($f.type.keyType, $f.type.valType)]
        #end if
        #set $initString = $initString + $toCPPType($f.type)
        #if $i != $len($m.fields) - 1
            #set $initString = $initString + ", "
        #end if
    #end for
    #set $initString = $initString + " >()"
    bp::class_<$className,
               bp::bases<Message>,
               boost::shared_ptr<$className>
              >("$className", $initString)
        // self_ns shouldn't be necessary here... gcc sux
        .def(bp::self_ns::str(bp::self_ns::self))
        // return policies are all return-by-value, safest, but not the most efficient
        #for $f in $m.fields
        .add_property(
            "${f.name}",
            bp::make_function(
                wrap(&${className}::get_${f.name}),
                bp::return_value_policy<bp::copy_const_reference>()
            ),
            wrap(&${className}::set_${f.name})
        )
        #end for
    ;
    #end for
    #end for
    
    // hackery for boost::shared_ptr<T const> ... see workarounds.h
    register_shared_ptrs_to_python<Message>();
    
    // have to explicitly export each type of stl container needed for
    // messages (!!!)
    emitRequiredContainers();
}


/** Helper structures for exporting instances of STL containers:
 ** (borrowing from http://wiki.python.org/moin/boost.python/StlContainers, but
 **  that code was a long way from even compiling... so not completely
 **  confidence inspiring!)
 **/

void IndexError(){
    PyErr_SetString(PyExc_IndexError, "Index out of range");
    bp::throw_error_already_set();
}

template<class T>
struct vec_item{
    typedef typename T::value_type V;
    static V& get(T& x, int i){
        if(i < 0) i += x.size();
        if(i >= 0 && i < int(x.size())) return x[i];
        IndexError();
    }
    static void set(T& x, int i, V const& v){
        if(i < 0) i += x.size();
        if(i >= 0 && i < int(x.size())) x[i] = v;
        else IndexError();
    }
    static void del(T& x, int i){
        if(i < 0) i += x.size();
        if(i >= 0 && i < int(x.size())) x.erase(x.begin() + i);
        else IndexError();
    }
    static void add(T& x, V const& v){
        x.push_back(v);
    }
};

template<class Key, class Val>
struct map_item{
    typedef std::map<Key,Val> Map;

    static Val& get(Map& self, const Key idx){
        typename Map::iterator i = self.find(idx);
        if(i != self.end()) return i->second;
        PyErr_SetString(PyExc_KeyError,"Map key not found");
        bp::throw_error_already_set();
    }

    static void set(Map& self, const Key idx, const Val val) { self[idx]=val; }

    static void del(Map& self, const Key n) { self.erase(n); }

    static bool in(Map const& self, const Key n) { return self.find(n) != self.end(); }

    static bp::list keys(Map const& self){
        bp::list t;
        for(typename Map::const_iterator it=self.begin(); it!=self.end(); ++it)
            t.append(it->first);
        return t;
    }
    static bp::list values(Map const& self){
        bp::list t;
        for(typename Map::const_iterator it=self.begin(); it!=self.end(); ++it)
            t.append(it->second);
        return t;
    }
    static bp::list items(Map const& self){
        bp::list t;
        for(typename Map::const_iterator it=self.begin(); it!=self.end(); ++it)
            t.append(bp::make_tuple(it->first, it->second));
        return t;
    }
};



void emitRequiredContainers(){
    // STL Vectors:
    #for $t in $requiredVectorTypes 
    #set $vect = "std::vector< " + $toCPPType(t) + " >"
    #set $vecn = $CPPContainerTypeName(t) + "Vec"
    // $vecn
    bp::class_< $vect >("$vecn")
        .def("__len__", &$vect::size)
        .def("clear", &$vect::clear)
        .def("append", &vec_item< $vect >::add, 
              bp::with_custodian_and_ward<1, 2>()) // let container keep value
        .def("__getitem__", &vec_item< $vect >::get,
             bp::return_value_policy<bp::copy_non_const_reference>())
        .def("__setitem__", &vec_item< $vect >::set,
             bp::with_custodian_and_ward<1,2>()) // to let container keep value
        .def("__delitem__", &vec_item< $vect >::del)
    ;
    #end for

    // STL Maps: TODO: unambiguous names!
    #for $kt, $vt in $requiredMapTypes
    #set $mapn = $CPPContainerTypeName(kt) + $CPPContainerTypeName(vt) + "Map"
    #set $mapt = "std::map< " + $toCPPType(kt) +", "+ $toCPPType(vt) +" >"
    #set $itemt = "map_item< " + $toCPPType(kt) +", "+ $toCPPType(vt) +" >"
    // $mapn
    bp::class_< $mapt >("$mapn")
        .def("__len__", &$mapt::size)
        .def("__getitem__", &${itemt}().get,
             bp::return_value_policy<bp::copy_non_const_reference>())
        .def("__setitem__", &${itemt}().set)
        .def("__delitem__", &${itemt}().del)
        .def("clear", &$mapt::clear)
        .def("__contains__", &${itemt}().in)
        .def("has_key", &${itemt}().in)
        .def("keys", &${itemt}().keys)
        .def("values", &${itemt}().values)
        .def("items", &${itemt}().items)
    ;
    
    #end for    
}

