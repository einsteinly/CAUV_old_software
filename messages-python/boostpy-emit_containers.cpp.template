/***  This is a generated file, do not edit ***/
\#include "workarounds.h" // _must_ be first
\#include <boost/python.hpp>
\#include <boost/python/str.hpp>

\#include "emit_generated.h"
\#include <generated/messages.h>

namespace bp = boost::python;
using namespace cauv;

/** Helper structures for exporting instances of STL containers:
 ** (borrowing from http://wiki.python.org/moin/boost.python/StlContainers, but
 **  that code was a long way from even compiling... so not completely
 **  confidence inspiring!)
 **/

inline void IndexError(){
    PyErr_SetString(PyExc_IndexError, "Index out of range");
    bp::throw_error_already_set();
}

template<class T>
struct vec_item{
    typedef typename T::value_type V;
    static V& get(T& x, int i){
        static V nothing;
        if(i < 0) i += x.size();
        if(i >= 0 && i < int(x.size())) return x[i];
        IndexError();
        return nothing;
    }
    static void set(T& x, int i, V const& v){
        if(i < 0) i += x.size();
        if(i >= 0 && i < int(x.size())) x[i] = v;
        else IndexError();
    }
    static void del(T& x, int i){
        if(i < 0) i += x.size();
        if(i >= 0 && i < int(x.size())) x.erase(x.begin() + i);
        else IndexError();
    }
    static void add(T& x, V const& v){
        x.push_back(v);
    }
};

template<class Key, class Val>
struct map_item{
    typedef std::map<Key,Val> Map;

    static Val& get(Map& self, const Key idx){
        static Val nothing;
        typename Map::iterator i = self.find(idx);
        if(i != self.end()) return i->second;
        PyErr_SetString(PyExc_KeyError,"Map key not found");
        bp::throw_error_already_set();
        return nothing;
    }

    static void set(Map& self, const Key idx, const Val val) { self[idx]=val; }

    static void del(Map& self, const Key n) { self.erase(n); }

    static bool in(Map const& self, const Key n) { return self.find(n) != self.end(); }

    static bp::list keys(Map const& self){
        bp::list t;
        for(typename Map::const_iterator it=self.begin(); it!=self.end(); ++it)
            t.append(it->first);
        return t;
    }
    static bp::list values(Map const& self){
        bp::list t;
        for(typename Map::const_iterator it=self.begin(); it!=self.end(); ++it)
            t.append(it->second);
        return t;
    }
    static bp::list items(Map const& self){
        bp::list t;
        for(typename Map::const_iterator it=self.begin(); it!=self.end(); ++it)
            t.append(bp::make_tuple(it->first, it->second));
        return t;
    }
};

void emitContainers(){
    // STL Vectors:
    #for $t in $requiredVectorTypes 
    #set $vect = "std::vector< " + $toCPPType(t) + " >"
    #set $vecn = $CPPContainerTypeName(t) + "Vec"
    // $vecn
    bp::class_< $vect >("$vecn")
        .def("__len__", &$vect::size)
        .def("clear", &$vect::clear)
        .def("append", &vec_item< $vect >::add, 
              bp::with_custodian_and_ward<1, 2>()) // let container keep value
        .def("__getitem__", &vec_item< $vect >::get,
             bp::return_value_policy<bp::copy_non_const_reference>())
        .def("__setitem__", &vec_item< $vect >::set,
             bp::with_custodian_and_ward<1,2>()) // to let container keep value
        .def("__delitem__", &vec_item< $vect >::del)
        .def("__iter__", bp::iterator< $vect >())
    ;
    #end for

    // STL Maps: TODO: unambiguous names!
    #for $kt, $vt in $requiredMapTypes
    #set $mapn = $CPPContainerTypeName(kt) + $CPPContainerTypeName(vt) + "Map"
    #set $mapt = "std::map< " + $toCPPType(kt) +", "+ $toCPPType(vt) +" >"
    #set $itemt = "map_item< " + $toCPPType(kt) +", "+ $toCPPType(vt) +" >"
    // $mapn
    bp::class_< $mapt >("$mapn")
        .def("__len__", &$mapt::size)
        .def("__getitem__", &${itemt}().get,
             bp::return_value_policy<bp::copy_non_const_reference>())
        .def("__setitem__", &${itemt}().set)
        .def("__delitem__", &${itemt}().del)
        .def("clear", &$mapt::clear)
        .def("__contains__", &${itemt}().in)
        .def("has_key", &${itemt}().in)
        .def("keys", &${itemt}().keys)
        .def("values", &${itemt}().values)
        .def("items", &${itemt}().items)
    ;
    
    #end for
}

