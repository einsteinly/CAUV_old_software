/***  This is a generated file, do not edit ***/
\#include "workarounds.h" // _must_ be first
\#include <boost/python.hpp>
\#include <boost/python/str.hpp>
\#include <boost/python/suite/indexing/vector_indexing_suite.hpp>
\#include <boost/python/suite/indexing/map_indexing_suite.hpp>

\#include "emit_generated.h"
\#include <generated/messages.h>
\#include <generated/serialmess.h>

\#include <boost/make_shared.hpp>
\#include <utility/serialisation-types.h>
\#include <utility/serialisation.h>

namespace bp = boost::python;
using namespace cauv;

template<typename T, typename aT = std::allocator<T> >
struct VectorWrapper:
    public std::vector<T,aT>,
    public bp::wrapper< std::vector<T> >{
    // Must re-implement std::vector<T> constructors that
    // bp::vector_indexing_suite requires:
    VectorWrapper()
        : std::vector<T,aT>(){
    }
    template <typename itT>
    VectorWrapper(itT first, itT last, const aT& a = aT())
        : std::vector<T,aT>(first, last, a){
    }
    VectorWrapper(VectorWrapper const& other)
        : std::vector<T,aT>(other), bp::wrapper< std::vector<T> >(other){
    }
    // Not entirely sure why this is needed...
    VectorWrapper(std::vector<T,aT> const& other)
        : std::vector<T,aT>(other), bp::wrapper< std::vector<T> >(){
    }
    // Add constructor for UnPickling:
    VectorWrapper(std::string const& serialised_data)
        : std::vector<T,aT>(){
        const_svec_ptr v  = boost::make_shared<svec_t>(
            serialised_data.data(), serialised_data.data() + serialised_data.size()
        );
        uint32_t used = deserialise(v, 0, *this);
        if(used != serialised_data.size())
            throw std::runtime_error("Bad Pickle");
    }
    std::string serialiseForPickle() const{
        svec_ptr v = boost::make_shared<svec_t>();
        serialise(v, *this);
        return std::string(v->begin(), v->end());
    }
};


#for $t in $requiredVectorTypes 
#set $vect = "VectorWrapper< " + $toCPPType(t) + " >"
#set $vecn = $CPPContainerTypeName(t) + "Vec"
struct ${vecn}Pickler: bp::pickle_suite{
    static bp::tuple getinitargs(${vect} const& a){
        return bp::make_tuple(a.serialiseForPickle());
    }
};
#end for

template<class Key, class Val>
struct MapHelper{
    typedef std::map<Key,Val> Map;

    static bp::list keys(Map const& self){
        bp::list t;
        for(typename Map::const_iterator it=self.begin(); it!=self.end(); ++it)
            t.append(it->first);
        return t;
    }
    static bp::list values(Map const& self){
        bp::list t;
        for(typename Map::const_iterator it=self.begin(); it!=self.end(); ++it)
            t.append(it->second);
        return t;
    }
    static bp::list items(Map const& self){
        bp::list t;
        for(typename Map::const_iterator it=self.begin(); it!=self.end(); ++it)
            t.append(bp::make_tuple(it->first, it->second));
        return t;
    }
};


void emitContainers(){
    // STL Vectors:
    #for $t in $requiredVectorTypes 
    #set $vect = "VectorWrapper< " + $toCPPType(t) + " >"
    #set $vecn = $CPPContainerTypeName(t) + "Vec"
    // $vecn
    bp::class_< $vect >("$vecn")
        .def(bp::init<std::string>())
        .def(bp::vector_indexing_suite< $vect >())
        .def_pickle(${vecn}Pickler())
        .def(bp::self_ns::str(bp::self_ns::self))
        .def(bp::self_ns::repr(bp::self_ns::self))
    ;
    from_python_sequence<$vect, variable_capacity_policy>();

#end for

    // STL Maps: TODO: unambiguous names!
    #for $kt, $vt in $requiredMapTypes
    #set $mapn = $CPPContainerTypeName(kt) + $CPPContainerTypeName(vt) + "Map"
    #set $mapt = "std::map< " + $toCPPType(kt) +", "+ $toCPPType(vt) +" >"
    #set $helpert = "MapHelper< " + $toCPPType(kt) +", "+ $toCPPType(vt) +" >"
    // $mapn
    bp::class_< $mapt >("$mapn")
        .def(bp::map_indexing_suite< $mapt >())
        .def("keys", &${helpert}().keys)
        .def("values", &${helpert}().values)
        .def("items", &${helpert}().items)
        .def(bp::self_ns::str(bp::self_ns::self))
        .def(bp::self_ns::repr(bp::self_ns::self))
    ;
    from_python_dict<$mapt, variable_capacity_map_policy>();
    
    #end for
}

