from pitz.bag import Bag
from pitz.entity import Entity
from django.http import QueryDict

#PITZ FIELD ANALYSIS STUFF

#these fields should not be modified by the user
known_pitz_fields = ('modified_time','created_time', 'created_by','frag','type','yaml_file_saved','uuid' )
 
#here we can define extra fields..
"""
example
'entity type plural name': {
        field name: field type,
        }
"""
extra_fields = {'comments':{
                            'entity': Entity#otherwise get_all_variables will resort to the first entry, which will be a particular type of entity
                            },
                'tasks':{
                         'attached_files': list#adds attached files field to tasks
                         },
                }

def get_all_variables(entity_type, noneditable=False):
    """
    returns a list of all known (editable by default) fields associated with this entity_type
    fields that are lists will be returned [entity type in list]
    checks (lowest priority first):
    fields in first entity of that type (if it exists) excluding fields known to be generated by pitz
    fields in the allowed types attribute of the class
    fields in the extra_fields dictionary defined here
    """
    fields = {}
    try:
        for variable in entity_type.all()[0]: #get the name/type of variables in the first member of the bag
            if noneditable or not variable in known_pitz_fields:
                fields[variable] = type(entity_type.all()[0][variable])
    except IndexError:
        pass
    fields.update(entity_type.allowed_types)
    if entity_type.plural_name in extra_fields:
        for field in extra_fields[entity_type.plural_name]:
            fields[field] = extra_fields[entity_type.plural_name][field]
    return fields

#some random stuff (needed later)
def title_or_str(obj):
    """
    given an entity property of unknown type, return a useful string
    """
    if isinstance(obj, Entity): return obj['title']
    return obj

#custom filter exception
class FilterError(Exception):
    def __init__(self, filter_id, msg_id, message):
        self.filter_id = filter_id
        self.msg_id = msg_id
        self.message = message
    def __str__(self):
        return str(self.messages)

#FILTERING SYSTEM STUFF

class order_obj():
    def __init__(self, values=[], reverse=[]):
        self.values = values
        self.reverse = reverse
        if len(self.reverse) < len(self.values):
            self.reverse.extend([''*(len(self.values)-len(self.reverse))])
    def __call__(self, e1, e2):
        for index, attr in enumerate(self.values):
            try:
                if not self.reverse[index]:
                    return cmp(e1[attr], e2[attr])
                return -cmp(e1[attr], e2[attr])
            except KeyError:
                continue
        return 0
    def to_string(self):
        return 'o='+'&o='.join(self.values)+'&r='+'&r='.join(self.reverse)
        
class ErrorCatcher():
    """
    intercepts filter errors and places them in a dictionary, counting filters of the same type from the same node
    """
    def __init__(self, filter_object, error_dict):
        self.filter_object = filter_object
        self.error_dict = error_dict
    def __call__(self, entity):
        try:
            return self.filter_object(entity)
        except FilterError as error:
            if error.filter_id in self.error_dict:
                if error.msg_id in self.error_dict[error.filter_id]:
                    self.error_dict[error.filter_id][error.msg_id][0] += 1
                    return
                self.error_dict[error.filter_id][error.msg_id] = [1, error.message]
                return
            self.error_dict[error.filter_id]={error.msg_id:[1, error.message]}
            return
            
#all the types of filter
class filter_obj():
    """
    All filters inherit from this, but should override subcall, and str represent with the filter method and filter initials respectively
    """
    def __init__(self, *args, **kwargs):
        """
        Set values. if from_str is specified then the first value is a string of indices seperated by, and the second is a list of values with values in indices corresponding to values for this function
        """
        if 'from_str' in kwargs:
            value_indices = args[0].split(',')
            self.values = [args[1][int(x)] for x in value_indices]
            return
        self.values = args
        return
    def __call__(self, entity):
        """
        encloses subcall in some try except statements to generate the right errors
        """
        try:
            return self.subcall(entity)
        except (IndexError, FilterError, TypeError) as error:
            if isinstance(error, FilterError):
                raise error
            elif isinstance(error, TypeError):
                raise FilterError(self,0,'Type Error. Probably means the filters are misconfigured.')
            raise FilterError(self,1,"Some value isn't set.")
    def subcall(self, entity):
        return True
    def to_list(self, filters, values, counter=0):
        """
        Converts the filter to a list of filter string representations and a list of values
        counter keeps track of the index so filters depending on other filters can specify those filter positions
        """
        value_pos=[]
        for value in self.values:
            filters, values, counter=value.to_list(filters, values, counter)
            value_pos.append(str(counter-1))
        filters.append(self.string_repr())
        values.append(','.join(value_pos))
        counter+=1
        return filters, values, counter
    def to_string(self):
        """
        Calls to_list then converts to a string
        """
        filters=[]
        values=[]
        filters, values, counter = self.to_list(filters, values)
        string = '&'.join(['f='+f+'&v='+values[i] for i, f in enumerate(filters)])
        return string
    def string_repr(self):
        return ''
        
#special cases (that arent really filters, more ways of accessing values)
class filter_entity_property(filter_obj):
    """
    an entity property
    note that calling a.b is like entity[a][b]
    if the property is another entity, returns the entity title
    """
    def __init__(self, name, *args, **kwargs):
        #regardless of the source, the second arg is always name
        self.name=name
    def __call__(self, entity):
        cur_obj=entity
        try:
            for x in self.name.split('.'):
                cur_obj = cur_obj[x]
        except (TypeError, KeyError):
            raise FilterError(self,0,'Could not find entity property '+self.name)
        return title_or_str(cur_obj)
    def to_list(self, filters, values, counter=0):
        filters.append('ep')
        values.append(self.name)
        counter+=1
        return filters, values, counter
    def string_repr(self):
        return 'ep'
class filter_value(filter_obj):
    def __init__(self, value, *args, **kwargs):
        #ditto
        self.value = value
    def __call__(self, entity):
        return self.value
    def to_list(self, filters, values, counter=0):
        filters.append('va')
        values.append(self.value)
        counter+=1
        return filters, values, counter
    def string_repr(self):
        return 'va'
        
class filter_null_obj(filter_obj):
    def to_list(self, filters, values, counter=0):
        return filters, values, counter
        
#filters
class filter_eq(filter_obj):
    def subcall(self, entity):
        return self.values[0](entity) == self.values[1](entity)
    def string_repr(self):
        return 'eq'
class filter_neq(filter_obj):
    def subcall(self, entity):
        return self.values[0](entity) != self.values[1](entity)
    def string_repr(self):
        return 'ne'
class filter_lt(filter_obj):
    def subcall(self, entity):
        return self.values[0](entity) < self.values[1](entity)
    def string_repr(self):
        return 'lt'
class filter_gt(filter_obj):
    def subcall(self, entity):
        return self.values[0](entity) > self.values[1](entity)
    def string_repr(self):
        return 'gt'
class filter_all(filter_obj):
    def subcall(self, entity):
        for value in self.values:
            if not value(entity): return False
        return True
    def string_repr(self):
        return 'ao'
class filter_none(filter_obj):
    def subcall(self, entity):
        for value in self.values:
            if value(entity): return False
        return True
    def string_repr(self):
        return 'no'
class filter_atleast_one(filter_obj):
    def subcall(self, entity):
        for value in self.values:
            if value(entity): return True
        return False
    def string_repr(self):
        return 'on'
class filter_and(filter_obj):
    def subcall(self, entity):
        return self.values[0](entity) and self.values[1](entity)
    def string_repr(self):
        return 'nd'
class filter_or(filter_obj):
    def subcall(self, entity):
        return self.values[0](entity) or self.values[1](entity)
    def string_repr(self):
        return 'or'
class filter_xor(filter_obj):
    def subcall(self, entity):
        return self.values[0](entity) ^ self.values[1](entity)
    def string_repr(self):
        return 'xo'
#uses pitz match dict on entities. not as flexible but quicker. Has to override some things.
class filter_matches_dict(filter_obj):
    def __init__(self, dict, *args, **kwargs):
        if 'from_str' in kwargs:
            #self.value = {pair[0]:pair[1] for pair in [x.split(':') for x in dict.split(';')]}
            self.value = {}
            for pair in [x.split(':') for x in dict.split(';')]:
                self.value[pair[0]] = pair[1]
            return
        self.value = dict
        return
    def __call__(self, entity):
        return entity.matches_dict(**self.value)
    def to_list(self, filters, values, counter=0):
        filters.append('md')
        values.append(';'.join([str(i)+':'+title_or_str(v) for i,v in self.value.items()]))
        counter+=1
        return filters, values, counter

#LISTS OF FILTERS
#all_filters is used to convert back to filters given a string representation
all_filters = {
            'ao':filter_all,
            'on':filter_atleast_one,
            'no':filter_none,
            'eq':filter_eq,
            'ne':filter_neq,
            'lt':filter_lt,
            'gt':filter_gt,
            'nd':filter_and,
            'or':filter_or,
            'xo':filter_xor,
            'md':filter_matches_dict,
            'ep':filter_entity_property,
            'va':filter_value,
            }

#specifies the list of filters javascript has to deal with, string_repr: (display name, number of values it accepts) -1 means unlimited no of values
js_filters = {
            'ao':('All of',-1),
            'on':('Atleast one of',-1),
            'no':('None of',-1),
            'eq':('equals',2),
            'ne':('does not equal',2),
            'lt':('is less than',2),
            'gt':('is greater than',2),
            'nd':('and',2),
            'or':('or',2),
            'xo':('xor',2),
            'md':('matches dictionary',1),
            'ep':('Entity Property',0),
            'va':('Value',0),
            '-':('-',0),
            }

def order_from_GET(GET_data):
    o=GET_data.getlist('o')
    r=GET_data.getlist('r')
    return order_obj(o, r)
    
def filter_from_GET(GET_data):
    """
    Given some GET data, extracts filter info and reconstructs the filter
    """
    #note that in filters appear in order of calcuability in the lists
    f=GET_data.getlist('f')
    v=GET_data.getlist('v')
    finished = []
    for index, filter in enumerate(f):
        finished.append(all_filters[filter](v[index], finished, from_str=True))
    if finished:
        return finished[-1]
    return filter_null_obj()
    
def filter_order_from_str(string):
    qdict = QueryDict(string)
    return filter_from_GET(qdict),order_from_GET(qdict)
    
