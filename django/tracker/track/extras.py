from pitz.bag import Bag
from pitz.entity import Entity
known_pitz_fields = ('modified_time','created_time', 'created_by','frag','type','yaml_file_saved','uuid' ) #created_by is defined in the save method of the form
#here we can define extra fields..
"""
example
'entity type plural name': {
        field name: field type,
        }
"""
extra_fields = { }

def get_all_variables(entity_type):
    """
    returns a list of all known editable fields associated with this entity_type
    fields that are lists will be returned [entity type in list]
    checks (lowest priority first):
    fields in first entity of that type (if it exists) excluding fields known to be generated by pitz
    fields in the allowed types attribute of the class
    fields in the extra_fields dictionary defined here
    """
    fields = {}
    try:
        for variable in entity_type.all()[0]: # get the name/type of variables in the first member of the bag
	    if not variable in known_pitz_fields:
                fields[variable] = type(entity_type.all()[0][variable])
    except IndexError:
        pass
    fields.update(entity_type.allowed_types)
    if entity_type.plural_name in extra_fields:
        fields.update(extra_fields[entity_type.plural_name])
    return fields

#some random stuff (needed later)
def title_or_str(obj):
    """
    given an entity property of unknown type, return a useful string
    """
    if isinstance(obj, Entity): return obj['title']
    return obj
#since filters cant tell the difference between filters, entity properties and values, they just call them all
class filter_entity_property():
    """
    an entity property
    note that calling a.b is like entity[a][b]
    """
    def __init__(self, name, *args, **kwargs):
        #regardless of the source, the second arg is always name
        self.name=name
    def __call__(self, entity):
        cur_obj=entity
        for x in self.name.split('.'):
            cur_obj = cur_obj[x]
        return cur_obj
    def to_list(self, filters, values, counter=0):
        filters.append('ep')
        values.append(self.name)
        counter+=1
        return filters, values, counter
class filter_value():
    def __init__(self, value, *args, **kwargs):
        #ditto
        self.value = value
    def __call__(self, entity):
        return self.value
    def to_list(self, filters, values, counter=0):
        filters.append('va')
        values.append(self.value)
        counter+=1
        return filters, values, counter
class filter_obj():
    def __init__(self, *args, **kwargs):
        if 'from_str' in kwargs:
            value_indices = args[0].split(',')
            self.values = [args[1][int(x)] for x in value_indices]
            return
        self.values = args
        return
    def __call__(self, entity):
        return True
    def to_list(self, filters, values, counter=0):
        value_pos=[]
        for value in self.values:
            filters, values, counter=value.to_list(filters, values, counter)
            value_pos.append(str(counter-1))
        filters.append(self.string_repr())
        values.append(','.join(value_pos))
        counter+=1
        return filters, values, counter
    def to_string(self):
        filters=[]
        values=[]
        filters, values, counter = self.to_list(filters, values)
        string = '&'.join(['f='+f+'&v='+values[i] for i, f in enumerate(filters)])
        return string
    def string_repr(self):
        return ''
        
class filter_null_obj(filter_obj):
    def to_list(self, filters, values, counter=0):
        return filters, values, counter
    
#since it gets used so much
#class filter_obj_2(filter_obj):
#    def __init__(self, value1, value2):
#        self.values = (value1, value2)
    
#filters
class filter_eq(filter_obj):
    def __call__(self, entity):
        return self.values[0](entity) == self.values[1](entity)
    def string_repr(self):
        return 'eq'
class filter_neq(filter_obj):
    def __call__(self, entity):
        return self.values[0](entity) != self.values[1](entity)
    def string_repr(self):
        return 'ne'
class filter_all(filter_obj):
    def __call__(self, entity):
        for value in self.values:
            if not value(entity): return False
        return True
    def string_repr(self):
        return 'ao'
class filter_none(filter_obj):
    def __call__(self, entity):
        for value in self.values:
            if value(entity): return False
        return True
    def string_repr(self):
        return 'no'
class filter_atleast_one(filter_obj):
    def __call__(self, entity):
        for value in self.values:
            if value(entity): return True
        return False
    def string_repr(self):
        return 'on'
class filter_and(filter_obj):
    def __call__(self, entity):
        return self.values[0](entity) and self.values[1](entity)
    def string_repr(self):
        return 'nd'
class filter_or(filter_obj):
    def __call__(self, entity):
        return self.values[0](entity) or self.values[1](entity)
    def string_repr(self):
        return 'or'
class filter_xor(filter_obj):
    def __call__(self, entity):
        return self.values[0](entity) ^ self.values[1](entity)
    def string_repr(self):
        return 'xo'
#uses pitz match dict on entities. not as flexible but quicker
class filter_matches_dict(filter_obj):
    def __init__(self, dict, *args, **kwargs):
        if 'from_str' in kwargs:
            #self.value = {pair[0]:pair[1] for pair in [x.split(':') for x in dict.split(';')]}
            self.value = {}
            for pair in [x.split(':') for x in dict.split(';')]:
                self.value[pair[0]] = pair[1]
            return
        self.value = dict
        return
    def __call__(self, entity):
        return entity.matches_dict(**self.value)
    def to_list(self, filters, values, counter=0):
        filters.append('md')
        values.append(';'.join([str(i)+':'+title_or_str(v) for i,v in self.value.items()]))
        counter+=1
        return filters, values, counter
        
all_filters = {
            'ao':filter_all,
            'on':filter_atleast_one,
            'no':filter_none,
            'eq':filter_eq,
            'ne':filter_neq,
            'nd':filter_and,
            'or':filter_or,
            'xo':filter_xor,
            'md':filter_matches_dict,
            'ep':filter_entity_property,
            'va':filter_value,
            }
            
js_filters = {
            'ao':('All of',-1),
            'on':('Atleast one of',-1),
            'no':('None of',-1),
            'eq':('equals',2),
            'ne':('does not equal',2),
            'nd':('and',2),
            'or':('or',2),
            'xo':('xor',2),
            'md':('matches dictionary',1),
            'ep':('Entity Property',0),
            'va':('Value',0),
            '-':('-',0),
            }

def filter_from_GET(GET_data):
    #not that in filters appear in order of calcuability in the lists
    f=GET_data.getlist('f')
    v=GET_data.getlist('v')
    finished = []
    for index, filter in enumerate(f):
        finished.append(all_filters[filter](v[index], finished, from_str=True))
    return finished[-1]
