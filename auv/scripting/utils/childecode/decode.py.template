## Template for CHIL decoder
## The API defined here should not be changed without some thought
\# This is a generated file, do not edit!
\# Generated for $source_revision


\# Standard Library
import base64

\# 3rd Party
import pyparsing as pp # MIT license

\# CAUV
import cauv.messaging as messaging

\# Definitions
l = pp.Suppress(pp.Literal('('))
r = pp.Suppress(pp.Literal(')'))
c = pp.Suppress(',')
hexchars = '0123456789abcdefABCDEF'

\# Basic Types
p_int32 = pp.Optional(pp.Literal('+') ^ pp.Literal('-')) + pp.Word(pp.nums)
p_int32.setParseAction(lambda x: int(x[0]))

p_uint32 = pp.Optional(pp.Literal('+')) + pp.Word(pp.nums) 
p_uint32.setParseAction(lambda x: int(x[0]))

p_byte = pp.Word(hexchars, exact=2) \# byte is actually only used in byteVec, which is overriden with a special case
p_byte.setParseAction(int)

p_bool = pp.Literal('0') ^ pp.Literal('1')
p_bool.setParseAction(lambda x: bool(x[0]))

p_int8 = p_int32

p_uint8 = p_uint32

p_int16 = p_int32

p_uint16 = p_uint32

p_float = pp.Word(pp.nums + '.eE+-')## TODO: more strict parsing
p_float.setParseAction(lambda x: float(x[0]))

p_double = p_float

##p_string = pp.suppress('"') + pp.Word('0123456789abcdefABCDEF') + pp.suppress('"')
p_string = pp.Word(hexchars)
p_string.setParseAction(lambda x: base64.b16decode(x[0]))

p_Image = pp.Forward()

\# Forward declarations
#for $s in $structs
p_${s.name} = pp.Forward()
    #for $f in $sorted($s.fields)
        #if $isSTLVector($f.type)
            $requiredVectorTypes.add($f.type.valType)
        #else if $isSTLMap($f.type)
            $requiredMapTypes.add(($f.type.keyType, $f.type.valType))
        #end if
    #end for
#end for

#for $v in $variants
p_${v.name} = pp.Forward()
#end for

#for $g in $groups
#for $m in $g.messages
    #for $f in $sorted($m.fields)
        #if $isSTLVector($f.type)
            #silent $requiredVectorTypes.add($f.type.valType)
        #else if $isSTLMap($f.type)
            #silent $requiredMapTypes.add(($f.type.keyType, $f.type.valType))
        #end if
    #end for
#end for
#end for
#set $allVecTypes, $allMapTypes = $addNestedTypes($requiredVectorTypes, $requiredMapTypes)
#for $t in $allVecTypes
    #set $vecn = $CPPContainerTypeName(t) + "Vec"
p_${vecn} = pp.Forward()
#end for

#for $kt, $vt  in $allMapTypes
    #set $mapn = $CPPContainerTypeName(kt) + $CPPContainerTypeName(vt) + "Map"
p_${mapn} = pp.Forward()
#end for

#for $e in $enums
p_${e.name} = pp.Forward()
#end for

\# Parse Structs
#for $s in $structs
p_${s.name} << pp.Group(l \
    #for i,f in $enumerate($s.fields)
        #if i + 1 != len($s.fields)
    + p_$toCHILType($f.type) + c \
        #else
    + p_$toCHILType($f.type) \
        #end if
    #end for
    + r)
p_${s.name}.setParseAction(lambda x: messaging.${s.name}(*x[0]))
#end for

\# Parse Variants
## TODO: think about variant serialisation format: probably need the parser to interpret
## second field depending on discriminant in first field
#for $v in $variants
p_${v.name} << l + (\
    #for i,t in enumerate($v.types)
        #if $i + 1 != len($v.types)
    p_$toCHILType($t) ^ \
        #else
    p_$toCHILType($t)) + \
        #end if
    #end for
    r
#end for

\# Parse Vector Types
#for $t in $allVecTypes
    #set $vecn = $CPPContainerTypeName(t) + "Vec"
    #if $vecn != "byteVec"
p_${vecn} << pp.Group(l + pp.delimitedList(p_${toCHILType($t)}) + pp.Optional(c) + r)
    #end if
def a_${vecn}(arg):
    t = messaging.${vecn}()
    for n in arg[0]:
        t.append(n)
    return t
p_${vecn}.setParseAction(a_${vecn})
#end for

# Special Case! Override byteVec definition
p_byteVec << pp.Word(hexchars)
def a_byteVec(arg):
    t = messaging.byteVec()
    for n in base64.b16decode(arg[0]):
        t.append(int(ord(n)))
    return t
p_byteVec.setParseAction(a_byteVec)

\# Parse Map Types
#for $kt, $vt  in $allMapTypes
    #set $mapn = $CPPContainerTypeName(kt) + $CPPContainerTypeName(vt) + "Map"
p_${mapn} << pp.Group(l + pp.delimitedList(l + p_${toCHILType($kt)} + c + p_${toCHILType($vt)} + r) + pp.Optional(c) + r)
def a_${mapn}(arg):
    t = messaging.${mapn}()
    for k,v in arg[0]:
        t[k] = v
    return t
p_${mapn}.setParseAction(a_${mapn})
#end for

\# Parse Enums
#for $e in $enums
p_${e.name} << p_int32
p_${e.name}.setParseAction(lambda x: messaging.${e.name}(x[0]))
#end for

\# Parse Messages
#for $g in $groups
#for $m in $g.messages
p_${m.name}Message = pp.Literal('${m.id}') + pp.Group(l \
    #for i,f in $enumerate($m.fields)
        #if i + 1 != len($m.fields)
    + p_$toCHILType($f.type) + c \
        #else
    + p_$toCHILType($f.type) \
        #end if
    #end for
    + r)
p_${m.name}Message.setParseAction(lambda x: messaging.${m.name}Message(*x[1]))
#end for
#end for


\# Parse any Message
p_Message = \
#for $i, $g in $enumerate($groups)
#for $j, $m in $enumerate($g.messages)
    #if $i + 1 == len($groups) and $j + 1 == len($g.messages)
    p_${m.name}Message
    #else
    p_${m.name}Message ^ \
    #end if
#end for
#end for

