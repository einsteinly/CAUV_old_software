<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Ssrc C++/Lua/Perl/Python/Ruby Bindings for Spread API: Lua/Perl/Python/Ruby API Differences</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">  
</head><body bgcolor="#ffffff">
<div style="text-align: left; clear: both;">
<a href="http://www.savarese.com/"><img src="logoSmall.jpg"
alt="Savarese Software Research Corporation" width="144" height="36" border="0" align="top"
hspace="0" vspace="0"></img></a>
<br clear="all" />
</div>

<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="index.html">index</a>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="script_notes">Lua/Perl/Python/Ruby API Differences </a></h1>The Lua, Perl, Python, and Ruby bindings use the same naming scheme as the C++ API in almost every case.<p>
No attempt has been made to customize the API to the idioms of the respective scripting languages. This allows you to use the C++ API documentation for all environments. However, a few differences are forced upon the API by the languages. See the unit tests in <code>tests/swig/lua</code>, <code>tests/swig/perl</code>, <code>tests/swig/python</code>, and <code>tests/swig/ruby</code> for usage examples.<h2><a class="anchor" name="lua_diff">
Lua Differences</a></h2>
<ul>
<li><code>#include &lt;<a class="el" href="a00027.html" title="This header includes all of the Spread toolkit wrapper classes from the ssrc::spread...">ssrc/spread.h</a>&gt;</code> becomes <code>require("ssrc.spread")</code></li><li>ssrc::spread::foo becomes ssrc.spread.foo</li><li>Static constants and enums that are class members cannot be accessed via the dot operator. Instead they are mapped to the class name followed by an underscore followed by the constant name. For example, <code>ssrc::spread::BaseMessage::SelfDiscard</code> becomes <code>ssrc.spread.BaseMessage_SelfDiscard</code>.</li><li>When you reference class constants, you must reference the class in which they are defined. For example, use <code>ssrc.spread.BaseMessage_SelfDiscard</code> instead of <code>ssrc.spread.Message_SelfDiscard</code></li><li>There are no bitwise logical operators in Lua. Therefore, you cannot use bitmasks. Instead of <code>ssrc::spread::BaseMessage::Reliable | ssrc::spread::BaseMessage::SelfDiscard</code> use <code>ssrc.spread.BaseMessage_ReliableSelfDiscard</code>.</li><li><a class="el" href="a00005.html" title="Error is a container for a Spread error code and is thrown by the library in only...">Error</a> and <a class="el" href="a00003.html" title="BufferSizeError is a container for a BufferTooShort or GroupTooShort errror, reporting...">BufferSizeError</a> cannot be caught in Lua, but you can prevent your program from exiting by using <code>pcall</code>. For example, the Lua unit tests do the following: <pre>
  function test_error()
    local succeeded, message = pcall(mbox.join, mbox, "####");
    assert(not succeeded)
  end
  </pre></li></ul>
<h2><a class="anchor" name="perl_diff">
Perl Differences</a></h2>
<ul>
<li><code>#include &lt;<a class="el" href="a00027.html" title="This header includes all of the Spread toolkit wrapper classes from the ssrc::spread...">ssrc/spread.h</a>&gt;</code> becomes <code>use ssrc::spread;</code></li><li>ssrc::spread::foo becomes ssrc::spread::foo</li><li><a class="el" href="a00030.html#56762346a675ed7f806eecb6c4fbe14c" title="Splits a private group name into its private name and process name components.">split_private_group()</a> is not implemented</li><li>When you reference class constants, you must reference the class in which they are defined. For example, use <code>$ssrc::spread::BaseMessage::SelfDiscard</code> instead of <code>$ssrc::spread::Message::SelfDiscard</code></li><li><a class="el" href="a00005.html" title="Error is a container for a Spread error code and is thrown by the library in only...">Error</a> and <a class="el" href="a00003.html" title="BufferSizeError is a container for a BufferTooShort or GroupTooShort errror, reporting...">BufferSizeError</a> can be caught in Perl only via the use of <code>eval</code>, which makes the exception available via the <code>$@</code> special variable. For example, the Perl unit tests do the following: <pre>
  sub test_error {
    eval { $mbox-&gt;join("####"); };
    is($@-&gt;error(), $ssrc::spread::Error::IllegalGroup);
  }
  </pre></li></ul>
<h2><a class="anchor" name="py_diff">
Python Differences</a></h2>
<ul>
<li><code>#include &lt;<a class="el" href="a00027.html" title="This header includes all of the Spread toolkit wrapper classes from the ssrc::spread...">ssrc/spread.h</a>&gt;</code> becomes <code>import ssrc.spread</code></li><li>ssrc::spread::foo becomes ssrc.spread.foo</li><li><a class="el" href="a00005.html#a6ab5130ac509a34058faad0b896e04e" title="Prints the message corresponding to the error via SP_error.">Error::print()</a> becomes Error._print()</li></ul>
<h2><a class="anchor" name="rb_diff">
Ruby Differences</a></h2>
<ul>
<li><code>#include &lt;<a class="el" href="a00027.html" title="This header includes all of the Spread toolkit wrapper classes from the ssrc::spread...">ssrc/spread.h</a>&gt;</code> becomes <code>require 'ssrc/spread'</code></li><li>ssrc::spread::foo becomes Ssrc::Spread::foo</li></ul>
<h2><a class="anchor" name="shared_diff">
Shared Differences</a></h2>
<ul>
<li>The Spread C API is not available in the Spread namespace.</li></ul>
<p>
<ul>
<li><a class="el" href="a00030.html#56762346a675ed7f806eecb6c4fbe14c" title="Splits a private group name into its private name and process name components.">split_private_group()</a> (not implemented in Perl) expects only the private group name as a parameter and returns an array (Ruby) or tuple (Python). For example: <pre>
  private_name, proc_name = ssrc.spread.split_private_group("#foo#bar")
  private_name == "foo" # This expression evaluates to True
  proc_name == "bar" # This expression evaluates to True
  </pre> In Lua <a class="el" href="a00030.html#56762346a675ed7f806eecb6c4fbe14c" title="Splits a private group name into its private name and process name components.">split_private_group()</a> returns a C++-style pair with .first and .second members, just like the C++ API.<br>
 You don't really need <a class="el" href="a00030.html#56762346a675ed7f806eecb6c4fbe14c" title="Splits a private group name into its private name and process name components.">split_private_group()</a> in the scripting environment because the same result can be obtained via string manipulation functions or regular expressions.</li><li>operator=() becomes copy()<br>
 For example: <pre>
  g1 = ssrc.spread.GroupList()
  g2 = ssrc.spread.GroupList()
  g1.add("foo")
  g2.copy(g1)
  g2.group(0) == "foo" # This expression evaluates to True.
  </pre></li><li>operator[] is unavailable. Use the corresponding accessor method instead. For example, use <a class="el" href="a00006.html#aa3f819143ae8096f9e8b8941841b962" title="Returns the group name at the specified index.">GroupList::group</a>.</li><li>Messages are treated as strings. If there is user demand, functions for creating raw memory buffers can be exported into the scripting environment. But for now, we feel it is best to serialize script objects into strings (e.g., with Python pickling) or create script bindings of your C++ data types that are sent as messages instead of trying to manipulate memory allocation in the scripting environment.</li><li><a class="el" href="a00004.html#a336762a9f23ac9b83862dd502b87a0e" title="Reads the specified number of bytes from the buffer into the provided destination...">Message::read</a> returns a string and <a class="el" href="a00004.html#5dc2d020bdab18aa0cf91f1821b21f52" title="Writes the specified number of bytes from the provided data into the buffer at the...">Message::write</a> expects a string parameter. <a class="el" href="a00004.html#a336762a9f23ac9b83862dd502b87a0e" title="Reads the specified number of bytes from the buffer into the provided destination...">Message::read</a> expects the maximum number of bytes to read as a parameter. For example: <pre>
  m = ssrc.spread.Message()
  m.write("foobar")
  m.rewind()
  s = m.read(m.size())
  "foobar" == s # This expression evaluates to True.
  </pre></li><li>The C++ versions of <a class="el" href="a00004.html#a336762a9f23ac9b83862dd502b87a0e" title="Reads the specified number of bytes from the buffer into the provided destination...">Message::read</a> and <a class="el" href="a00004.html#5dc2d020bdab18aa0cf91f1821b21f52" title="Writes the specified number of bytes from the provided data into the buffer at the...">Message::write</a> are available as <code>readn</code> and <code>writen</code>. Note, that <code>readn</code> is dangerous (e.g., strings are supposed to be immutable in Python) and should be avoided unless you know exactly what you're doing.</li><li><a class="el" href="a00010.html#009d088825a25c0cc45295f6314d98dd" title="Adds a message part to the ScatterMessage with a designated number of bytes indicating...">ScatterMessage::add(const void *, unsigned int)</a> and <a class="el" href="a00007.html#12156b3d3dc7b4033416391f680e189c" title="Adds a message part to the internal ScatterMessage.">Mailbox::add_message_part(const void *, unsigned int)</a> expect only a string as a parameter (same as the <a class="el" href="a00004.html#5dc2d020bdab18aa0cf91f1821b21f52" title="Writes the specified number of bytes from the provided data into the buffer at the...">Message::write</a> mapping). You should avoid using this form of the method for receives. Instead, use <a class="el" href="a00009.html" title="Message is a reusable and resizable data buffer for sending and receiving messages...">Message</a> parts for receives, or you may overwrite script data structures in unpredictable ways.</li></ul>
<h2><a class="anchor" name="considerations">
Additional Considerations</a></h2>
The <a class="el" href="a00007.html" title="The Mailbox class wraps the file descriptor returned after establishing a connection...">Mailbox</a> class uses the C++ idiom of resource acquisition is initialization. Therefore, no disconnect method is exposed and the disconnect happens in the destructor. In a garbage-collected scripting language, this means the disconnect may not happen at a predictable point when you stop using the object. You can invoke <a class="el" href="a00007.html#050fbc457d1e469ecef9a135312d68af" title="Closes the connection to the Spread daemon without notifying the daemon.">Mailbox::kill</a> to free the file descriptor immediately, but don't continue to use the object afterward.<p>
In order to specify a connection timeout, you may use the <a class="el" href="a00011.html" title="Timeout is a simple wrapper around Sptread::sp_time the Spread C API&#39;s Spread::sp_time...">Timeout</a> class or you may specify a timeout in seconds with a single integer. For example, to specify a connection timeout of 3 seconds in Python, you could use: <pre>
mbox = ssrc.spread.Mailbox("4803@localhost", "", True, ssrc.spread.Timeout(3));</pre> or: <pre>
mbox = ssrc.spread.Mailbox("4803@localhost", "", True, 3);</pre><p>
You can't access the contents of a <a class="el" href="a00009.html" title="Message is a reusable and resizable data buffer for sending and receiving messages...">Message</a> directly via <code>&amp;<a class="el" href="a00009.html" title="Message is a reusable and resizable data buffer for sending and receiving messages...">Message</a>[0]</code> as in C++. Instead, you always have to read and write the contents using <a class="el" href="a00004.html#a336762a9f23ac9b83862dd502b87a0e" title="Reads the specified number of bytes from the buffer into the provided destination...">Message::read</a> and <a class="el" href="a00004.html#5dc2d020bdab18aa0cf91f1821b21f52" title="Writes the specified number of bytes from the provided data into the buffer at the...">Message::write</a>. Because messages are treated as strings in the script environment, your data shouldn't contain null/0 characters. For example, if you write two strings to a message in a row and read them back into one string, you'll find that the result is treated as only the first string because of the null termination. For example: <pre>
m = ssrc.spread.Message()
m.write("foo")
m.write("bar")
m.rewind()
s = m.read(m.size())
"foo" == s # This expression evaluates to True.
"foobar" == s # This expression evaluates to False.
m.rewind()
s1 = m.read(4)
s2 = m.read(4)
"foo" == s1 # This expression evaluates to True.
"bar" == s2 # This expression evaluates to True.
</pre> As long as you use the script environment's object serialization mechanisms, you shouldn't run into any problems in this regard.<p>
Don't add raw data parts (things that are not of type <a class="el" href="a00009.html" title="Message is a reusable and resizable data buffer for sending and receiving messages...">Message</a>) to <a class="el" href="a00010.html#009d088825a25c0cc45295f6314d98dd" title="Adds a message part to the ScatterMessage with a designated number of bytes indicating...">ScatterMessage::add</a> or <a class="el" href="a00007.html#12156b3d3dc7b4033416391f680e189c" title="Adds a message part to the internal ScatterMessage.">Mailbox::add_message_part</a> if they will be garbage-collected before a send. For example: <pre>
s = "foo"
mbox.add_message_part(s)
s = None # Don't do this before the send or you may segfault!
mbox.send()
</pre> </div>
<hr />
<div style="float: left;">
<a href="http://www.savarese.com/"><img src="logoSmall.jpg"
alt="Savarese Software Research Corporation" width="144" height="36" border="0" align="top"
hspace="0" vspace="0"></img></a>
</div>
<div style="text-align:right">
Copyright &#169; 2006-2009 Savarese Software Research Corporation. All rights reserved.
</div>
</body></html>
